<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI Prompting Framework Selector</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: linear-gradient(to bottom right, #0f172a, #581c87, #0f172a);
      min-height: 100vh;
    }
  </style>
</head>
<body>
<div id="app"></div>

<script>
/* =========================
   DECISION TREE + FRAMEWORKS
   ========================= */

const decisions = {
  start: {
    question: "What's your primary goal?",
    options: [
      { text: "Quick information or simple task", next: "simple" },
      { text: "Creating content (writing, marketing)", next: "content" },
      { text: "Complex analysis or problem-solving", next: "complex" },
      { text: "Verifying accuracy of information", next: "verify" },
      { text: "Teaching or explaining concepts", next: "teaching" },
      { text: "Brainstorming and ideation", next: "creative" },
      { text: "Data analysis and research", next: "data" }
    ]
  },

  simple: {
    question: "How well-defined is your task?",
    options: [
      { text: "Very clear — I know exactly what I want", next: "rtf" },
      { text: "Need some structure and grounding", next: "aim" },
      { text: "I want the AI to ask clarifying questions first", next: "flipped" }
    ]
  },

  content: {
    question: "What type of content are you creating?",
    options: [
      { text: "Marketing / brand content", next: "costar" },
      { text: "Long-form writing (articles, essays)", next: "outline" },
      { text: "Creative writing or storytelling", next: "saga" },
      { text: "Just need a quick draft", next: "rtf" }
    ]
  },

  complex: {
    question: "What kind of complexity?",
    options: [
      { text: "Multi-step process with dependencies", next: "risen" },
      { text: "Multiple viable approaches", next: "tot" },
      { text: "Need explicit step-by-step reasoning", next: "cot" },
      { text: "Large ambiguous problem", next: "decomposition" }
    ]
  },

  verify: {
    question: "What are you verifying?",
    options: [
      { text: "Factual accuracy or math", next: "consistency" },
      { text: "Quality of reasoning", next: "self_refine" },
      { text: "Multiple viewpoints", next: "perspectives" }
    ]
  },

  teaching: {
    question: "What teaching style do you want?",
    options: [
      { text: "Explain simply from first principles", next: "feynman" },
      { text: "Teach by asking questions", next: "socratic" },
      { text: "Adapt explanation by audience level", next: "audience_adapt" }
    ]
  },

  creative: {
    question: "What kind of ideation?",
    options: [
      { text: "Generate many ideas quickly", next: "scamper" },
      { text: "Challenge assumptions", next: "contrarian" },
      { text: "Iterate and refine ideas", next: "iterate" }
    ]
  },

  data: {
    question: "What is your data task?",
    options: [
      { text: "Compare options or tools", next: "comparison" },
      { text: "Deep research", next: "research_deep" },
      { text: "Synthesize many sources", next: "synthesis" }
    ]
  },

  /* =========================
     FRAMEWORK DEFINITIONS
     ========================= */

  rtf: {
    framework: "RTF",
    title: "Role · Task · Format",
    description:
      "RTF is an execution-first prompting framework designed to minimize ambiguity and variance. "
      + "It constrains the model’s perspective (Role), intent (Task), and output shape (Format), "
      + "making it ideal for repeatable, production-grade tasks.",

    when: [
      "You know exactly what you want",
      "Operational or repeatable tasks",
      "High-volume prompting",
      "Latency and consistency matter"
    ],

    avoid: [
      "Exploratory problems",
      "Strategic decision-making",
      "Creative ideation"
    ],

    structure:
      "Role: Define the expertise or perspective\n"
      + "Task: Specify the exact action\n"
      + "Format: Constrain structure, length, and tone",

    example:
      "Role: Senior B2B SaaS copywriter\n"
      + "Task: Write a follow-up email to a demo attendee who went silent\n"
      + "Format: 5 sentences, professional but friendly, one CTA, no emojis"
  },

  aim: {
    framework: "AIM",
    title: "Actor · Input · Mission",
    description:
      "AIM is a balanced, general-purpose framework that works well when context matters but rigid steps are unnecessary. "
      + "It’s an excellent default for most professional use cases.",

    when: [
      "Moderate complexity tasks",
      "Everyday professional prompting",
      "You want structure without rigidity"
    ],

    avoid: [
      "Highly complex workflows",
      "One-word queries"
    ],

    structure:
      "Actor: Who the model is acting as\n"
      + "Input: Relevant background or data\n"
      + "Mission: What success looks like",

    example:
      "Actor: Senior QA engineer\n"
      + "Input: Node.js payment retry service using Stripe\n"
      + "Mission: Propose a testing strategy that maximizes confidence"
  },

  risen: {
    framework: "RISEN",
    title: "Role · Instructions · Steps · End goal · Narrowing",
    description:
      "RISEN is a high-control framework for complex, multi-stage workflows. "
      + "It reduces drift by explicitly defining sequence, constraints, and deliverables.",

    when: [
      "Complex analytical tasks",
      "Order of operations matters",
      "High-stakes or repeatable workflows"
    ],

    avoid: [
      "Quick questions",
      "Creative exploration"
    ],

    structure:
      "Role → Instructions → Steps → End Goal → Narrowing",

    example:
      "Role: SaaS retention strategist\n"
      + "Instructions: Analyze churn\n"
      + "Steps: Segment → Correlate → Diagnose → Prioritize\n"
      + "End Goal: Exec-ready recommendations\n"
      + "Narrowing: Enterprise customers only"
  },

  costar: {
    framework: "COSTAR",
    title: "Context · Objective · Style · Tone · Audience · Response",
    description:
      "COSTAR is optimized for content where voice, tone, and audience alignment matter. "
      + "It dramatically reduces misalignment in marketing and public-facing communication.",

    when: [
      "Marketing or brand content",
      "Audience-specific messaging",
      "Public communication"
    ],

    avoid: [
      "Internal analysis",
      "Data-heavy tasks"
    ],

    structure:
      "Context → Objective → Style → Tone → Audience → Response",

    example:
      "Context: Mental health app competing with Headspace\n"
      + "Objective: Get therapists to recommend it\n"
      + "Style: NYT Health\n"
      + "Tone: Trustworthy\n"
      + "Audience: LCSWs\n"
      + "Response: One-page overview"
  },

  tot: {
    framework: "Tree of Thoughts",
    title: "Multi-Path Reasoning",
    description:
      "Tree of Thoughts explores multiple solution paths before committing, making it ideal for strategic decisions "
      + "where early commitment is risky.",

    when: [
      "Strategic decisions",
      "Multiple viable solutions",
      "High-impact choices"
    ],

    avoid: [
      "Simple execution tasks",
      "Time-critical queries"
    ],

    structure:
      "Generate approaches → Evaluate → Select → Deepen",

    example:
      "Problem: Reduce cloud costs by 30%\n"
      + "A: Optimize architecture\n"
      + "B: Migrate services\n"
      + "C: Redesign boundaries\n"
      + "Evaluate on cost, risk, timeline, then expand best option"
  },

  consistency: {
    framework: "Self-Consistency",
    title: "Accuracy via Repetition",
    description:
      "Self-Consistency improves reliability by generating multiple independent answers "
      + "and identifying consensus and uncertainty.",

    when: [
      "Math or factual accuracy",
      "High cost of error"
    ],

    avoid: [
      "Creative tasks",
      "Opinion-based work"
    ],

    structure:
      "Repeat → Compare → Consensus → Investigate divergence",

    example:
      "Answer this question 5 times independently, then identify the consensus and explain discrepancies."
  },

  cot: {
    framework: "Chain of Thought",
    title: "Step-by-Step Reasoning",
    description:
      "Chain of Thought makes reasoning explicit, improving correctness on complex logic problems.",

    when: [
      "Math and logic problems",
      "Transparency required"
    ],

    avoid: [
      "Simple facts",
      "Creative writing"
    ],

    structure:
      "Think step-by-step before answering",

    example:
      "Think step-by-step:\n"
      + "1. Identify variables\n"
      + "2. Apply formula\n"
      + "3. Verify result"
  },

  feynman: {
    framework: "Feynman Technique",
    title: "Explain by Simplifying",
    description:
      "The Feynman Technique enforces true understanding by requiring explanations "
      + "that a beginner can follow.",

    when: [
      "Teaching",
      "Learning new domains"
    ],

    avoid: [
      "Expert documentation"
    ],

    structure:
      "Explain simply → Avoid jargon → Use analogies",

    example:
      "Explain transformers as if teaching a curious 12-year-old."
  },

  socratic: {
    framework: "Socratic Method",
    title: "Learn Through Questions",
    description:
      "The Socratic method teaches by guiding learners with questions instead of giving answers.",

    when: [
      "Teaching reasoning",
      "Developing understanding"
    ],

    avoid: [
      "Need quick answers"
    ],

    structure:
      "Ask guiding questions instead of answering",

    example:
      "Don’t answer directly. Ask questions that help me discover the answer myself."
  },

  scamper: {
    framework: "SCAMPER",
    title: "Structured Ideation",
    description:
      "SCAMPER systematically generates ideas by applying seven creative lenses.",

    when: [
      "Product ideation",
      "Creative blocks"
    ],

    avoid: [
      "Execution tasks"
    ],

    structure:
      "Substitute, Combine, Adapt, Modify, Put to other use, Eliminate, Reverse",

    example:
      "Apply SCAMPER to redesign a coffee mug."
  },

  decomposition: {
    framework: "Problem Decomposition",
    title: "Break Problems Down",
    description:
      "Decomposition reduces overwhelm by splitting large problems into manageable sub-problems.",

    when: [
      "Large ambiguous problems"
    ],

    avoid: [
      "Simple tasks"
    ],

    structure:
      "Identify sub-problems → dependencies → priorities",

    example:
      "Break launching a SaaS into validation, tech, marketing, funding."
  }
};

/* =========================
   SIMPLE RENDER LOGIC
   ========================= */

let currentStep = "start";
let path = [];

function render() {
  const app = document.getElementById("app");
  const current = decisions[currentStep];
  const isFramework = current.framework;

  app.innerHTML = `
    <div class="min-h-screen p-8">
      <div class="max-w-4xl mx-auto bg-white/10 backdrop-blur rounded-2xl p-8 border border-white/20">
        ${!isFramework ? `
          <h2 class="text-2xl font-bold text-white mb-6">${current.question}</h2>
          <div class="space-y-3">
            ${current.options.map(o => `
              <button onclick="choose('${o.next}')"
                class="w-full p-4 bg-white/5 hover:bg-white/20 text-white rounded-xl border border-white/10">
                ${o.text}
              </button>
            `).join("")}
          </div>
        ` : `
          <h2 class="text-3xl font-bold text-white mb-2">${current.framework}</h2>
          <p class="text-purple-200 text-lg mb-4">${current.title}</p>
          <p class="text-white mb-6">${current.description}</p>

          <div class="grid md:grid-cols-2 gap-4 mb-6">
            <div class="bg-green-500/10 p-4 rounded">
              <h3 class="text-green-400 font-semibold mb-2">Use When</h3>
              <ul>${current.when.map(w => `<li>• ${w}</li>`).join("")}</ul>
            </div>
            <div class="bg-red-500/10 p-4 rounded">
              <h3 class="text-red-400 font-semibold mb-2">Avoid When</h3>
              <ul>${current.avoid.map(a => `<li>• ${a}</li>`).join("")}</ul>
            </div>
          </div>

          <pre class="bg-white/5 p-4 rounded mb-4 text-sm text-white">${current.structure}</pre>
          <pre class="bg-white/5 p-4 rounded text-sm text-white">${current.example}</pre>
        `}

        <div class="flex justify-between mt-6">
          ${path.length ? `<button onclick="back()" class="text-white">← Back</button>` : `<span></span>`}
          <button onclick="reset()" class="bg-purple-600 px-4 py-2 rounded text-white">Start Over</button>
        </div>
      </div>
    </div>
  `;
}

function choose(next means next) {}
function choose(next) {
  path.push(currentStep);
  currentStep = next;
  render();
}

function back() {
  currentStep = path.pop();
  render();
}

function reset() {
  currentStep = "start";
  path = [];
  render();
}

render();
</script>
</body>
</html>
